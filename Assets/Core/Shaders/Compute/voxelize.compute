#version 460 core
layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

layout (binding = 0, r32ui) uniform uimage3D u_VoxelGrid;

struct DebugVoxelInfo 
{
    vec4 centroid_data;
    vec4 relativePos_data;
    ivec4 centerVoxel_data;
};

layout(std430, binding = 1) readonly buffer TriangleVertices 
{
    vec3 vertices[];
};

layout(std430, binding = 2) buffer DebugOutput 
{
    DebugVoxelInfo debugInfo[];
};

uniform vec3 u_GridWorldSize;
uniform vec3 u_GridCenter;
uniform ivec3 u_GridResolution;

vec2 projectAABB(vec3 axis, vec3 aabbMin, vec3 aabbMax) 
{
    vec3 center = (aabbMin + aabbMax) * 0.5;
    vec3 extents = (aabbMax - aabbMin) * 0.5;
    float r = extents.x * abs(dot(axis, vec3(1,0,0))) +
              extents.y * abs(dot(axis, vec3(0,1,0))) +
              extents.z * abs(dot(axis, vec3(0,0,1)));
    float c = dot(axis, center);
    return vec2(c - r, c + r); 
}

bool TriangleIntersectsAABB(vec3 v0, vec3 v1, vec3 v2, vec3 aabbMin, vec3 aabbMax)
{
    vec3 e0 = v1 - v0;
    vec3 e1 = v2 - v1;
    vec3 e2 = v0 - v2;

    vec3 aabbNormals[3] = vec3[3](vec3(1, 0, 0), vec3(0, 1, 0), vec3(0, 0, 1));
    for (int i = 0; i < 3; i++) 
    {
        vec3 axis = aabbNormals[i];
        float triMin = min(min(dot(v0, axis), dot(v1, axis)), dot(v2, axis));
        float triMax = max(max(dot(v0, axis), dot(v1, axis)), dot(v2, axis));
        vec2 aabbProj = projectAABB(axis, aabbMin, aabbMax);
        if (triMax < aabbProj.x || triMin > aabbProj.y) return false;
    }

    vec3 triNormal = cross(e0, e1);
   
    if (length(triNormal) > 1e-6) 
    {
        triNormal = normalize(triNormal);
        float triOffset = dot(triNormal, v0);
        vec2 aabbProj = projectAABB(triNormal, aabbMin, aabbMax);
        if (aabbProj.y < triOffset || aabbProj.x > triOffset) return false;
    } 

    vec3 triEdges[3] = vec3[3](e0, e1, e2);
    vec3 aabbEdgeNormals[3] = vec3[3](vec3(1, 0, 0), vec3(0, 1, 0), vec3(0, 0, 1)); 

    for (int i = 0; i < 3; i++) 
    { 
        for (int j = 0; j < 3; j++) 
        { 
            vec3 axis = cross(triEdges[i], aabbEdgeNormals[j]);
            if (length(axis) > 1e-6) 
            { 
                axis = normalize(axis); 
                float triMin = min(min(dot(v0, axis), dot(v1, axis)), dot(v2, axis));
                float triMax = max(max(dot(v0, axis), dot(v1, axis)), dot(v2, axis));
                vec2 aabbProj = projectAABB(axis, aabbMin, aabbMax);
                if (triMax < aabbProj.x || triMin > aabbProj.y) return false;
            }
        }
    }
    return true; 
}

void main()
{
    uint triangleIndex = gl_GlobalInvocationID.x;

    uint numVerticesInBuffer = vertices.length();
    uint vertexIndexBase = triangleIndex * 3;

    if ((vertexIndexBase + 2) >= numVerticesInBuffer) {
        return;
    }

    // Read vertices
    vec3 v_0 = vertices[vertexIndexBase + 0];
    vec3 v_1 = vertices[vertexIndexBase + 1];
    vec3 v_2 = vertices[vertexIndexBase + 2];

    // Calculate triangle's world-space AABB
    vec3 triMin = min(min(v_0, v_1), v_2);
    vec3 triMax = max(max(v_0, v_1), v_2);

    vec3 normMin_0_to_1 = ((triMin - u_GridCenter) / u_GridWorldSize) + 0.5;
    vec3 normMax_0_to_1 = ((triMax - u_GridCenter) / u_GridWorldSize) + 0.5;

    ivec3 minVoxelCoord = ivec3(floor(normMin_0_to_1 * vec3(u_GridResolution)));
    ivec3 maxVoxelCoord = ivec3(ceil(normMax_0_to_1 * vec3(u_GridResolution)));

    minVoxelCoord = max(ivec3(0), minVoxelCoord);
    maxVoxelCoord = min(u_GridResolution - 1, maxVoxelCoord);

    vec3 voxelWorldSize = u_GridWorldSize / vec3(u_GridResolution);

    // Iterate over potentially overlapping voxels
    for (int z = minVoxelCoord.z; z <= maxVoxelCoord.z; ++z) 
    {
        for (int y = minVoxelCoord.y; y <= maxVoxelCoord.y; ++y) 
        {
            for (int x = minVoxelCoord.x; x <= maxVoxelCoord.x; ++x) 
            {
                ivec3 currentVoxelCoord = ivec3(x, y, z);

                vec3 normVoxelMin_0_to_1 = vec3(currentVoxelCoord) / vec3(u_GridResolution);
                vec3 normVoxelMin_NegHalf = normVoxelMin_0_to_1 - 0.5;
                vec3 voxelMin_World = normVoxelMin_NegHalf * u_GridWorldSize + u_GridCenter;

                vec3 voxelMax_World = voxelMin_World + voxelWorldSize;

                // SAT test
                if (TriangleIntersectsAABB(v_0, v_1, v_2, voxelMin_World, voxelMax_World)) 
                {
                    imageAtomicOr(u_VoxelGrid, currentVoxelCoord, 1u);
                }
            }
        }
    }
}