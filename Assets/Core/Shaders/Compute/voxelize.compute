#version 460 core
layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

layout (binding = 0, r32ui) uniform uimage3D u_OccupancyGrid; 
layout (binding = 1, r32ui) uniform uimage3D u_EmissionR;     
layout (binding = 2, r32ui) uniform uimage3D u_EmissionG;     
layout (binding = 3, r32ui) uniform uimage3D u_EmissionB; 

struct DebugVoxelInfo 
{
    vec4 centroid_data;
    vec4 relativePos_data;
    ivec4 centerVoxel_data;
};

struct TriangleWithEmission
{
    vec4 v0;
    vec4 v1;
    vec4 v2;
    vec4 emission;
};

layout(std430, binding = 1) readonly buffer TriangleVertices 
{
    TriangleWithEmission triangles[];
};

layout(std430, binding = 2) buffer DebugOutput 
{
    DebugVoxelInfo debugInfo[];
};

uniform vec3 u_GridWorldSize;
uniform vec3 u_GridCenter;
uniform ivec3 u_GridResolution;

const float UINT16_MAX_F = 65535.0;
const float epsilon = 1e-6;

vec2 projectAABB(vec3 axis, vec3 aabbMin, vec3 aabbMax) 
{
    vec3 center = (aabbMin + aabbMax) * 0.5;
    vec3 extents = (aabbMax - aabbMin) * 0.5;
    float r = extents.x * abs(dot(axis, vec3(1,0,0))) +
              extents.y * abs(dot(axis, vec3(0,1,0))) +
              extents.z * abs(dot(axis, vec3(0,0,1)));
    float c = dot(axis, center);
    return vec2(c - r, c + r); 
}

bool TriangleIntersectsAABB(vec3 v0, vec3 v1, vec3 v2, vec3 aabbMin, vec3 aabbMax)
{
    vec3 e0 = v1 - v0;
    vec3 e1 = v2 - v1;
    vec3 e2 = v0 - v2;

    vec3 aabbNormals[3] = vec3[3](vec3(1, 0, 0), vec3(0, 1, 0), vec3(0, 0, 1));
    for (int i = 0; i < 3; i++) 
    {
        vec3 axis = aabbNormals[i];
        float triMin = min(min(dot(v0, axis), dot(v1, axis)), dot(v2, axis));
        float triMax = max(max(dot(v0, axis), dot(v1, axis)), dot(v2, axis));
        vec2 aabbProj = projectAABB(axis, aabbMin, aabbMax);
        if (triMax < aabbProj.x || triMin > aabbProj.y) return false;
    }

    vec3 triNormal = cross(e0, e1);
   
    if (length(triNormal) > 1e-6) 
    {
        triNormal = normalize(triNormal);
        float triOffset = dot(triNormal, v0);
        vec2 aabbProj = projectAABB(triNormal, aabbMin, aabbMax);
        if (aabbProj.y < triOffset || aabbProj.x > triOffset) return false;
    } 

    vec3 triEdges[3] = vec3[3](e0, e1, e2);
    vec3 aabbEdgeNormals[3] = vec3[3](vec3(1, 0, 0), vec3(0, 1, 0), vec3(0, 0, 1)); 

    for (int i = 0; i < 3; i++) 
    { 
        for (int j = 0; j < 3; j++) 
        { 
            vec3 axis = cross(triEdges[i], aabbEdgeNormals[j]);
            if (length(axis) > 1e-6) 
            { 
                axis = normalize(axis); 
                float triMin = min(min(dot(v0, axis), dot(v1, axis)), dot(v2, axis));
                float triMax = max(max(dot(v0, axis), dot(v1, axis)), dot(v2, axis));
                vec2 aabbProj = projectAABB(axis, aabbMin, aabbMax);
                if (triMax < aabbProj.x || triMin > aabbProj.y) return false;
            }
        }
    }
    return true; 
}

void main()
{
    uint triangleIndex = gl_GlobalInvocationID.x;

    if (triangleIndex >= triangles.length()) 
    {
        return;
    }

    TriangleWithEmission tri = triangles[triangleIndex];
    vec3 v_0 = tri.v0.xyz;
    vec3 v_1 = tri.v1.xyz;
    vec3 v_2 = tri.v2.xyz;
    vec3 emission = tri.emission.rgb;

    // Calculate triangle's world-space AABB
    vec3 triMin = min(min(v_0, v_1), v_2);
    vec3 triMax = max(max(v_0, v_1), v_2);

    vec3 normMin_0_to_1 = ((triMin - u_GridCenter) / u_GridWorldSize) + 0.5;
    vec3 normMax_0_to_1 = ((triMax - u_GridCenter) / u_GridWorldSize) + 0.5;

    ivec3 minVoxelCoord = ivec3(floor(normMin_0_to_1 * vec3(u_GridResolution)));
    ivec3 maxVoxelCoord = ivec3(ceil(normMax_0_to_1 * vec3(u_GridResolution)));

    minVoxelCoord = max(ivec3(0), minVoxelCoord);
    maxVoxelCoord = min(u_GridResolution - 1, maxVoxelCoord);

    vec3 voxelWorldSize = u_GridWorldSize / vec3(u_GridResolution);

    bool hasEmission = (dot(emission, emission) > epsilon * epsilon);
    uvec3 encodedEmission = uvec3(0u); 
    if (hasEmission)
    {
        encodedEmission = uvec3(clamp(emission * UINT16_MAX_F, 0.0, UINT16_MAX_F));
    }

    // Iterate over potentially overlapping voxels
    for (int z = minVoxelCoord.z; z <= maxVoxelCoord.z; ++z) 
    {
        for (int y = minVoxelCoord.y; y <= maxVoxelCoord.y; ++y) 
        {
            for (int x = minVoxelCoord.x; x <= maxVoxelCoord.x; ++x) 
            {
                ivec3 currentVoxelCoord = ivec3(x, y, z);

                vec3 normVoxelMin_0_to_1 = vec3(currentVoxelCoord) / vec3(u_GridResolution);
                vec3 normVoxelMin_NegHalf = normVoxelMin_0_to_1 - 0.5;
                vec3 voxelMin_World = normVoxelMin_NegHalf * u_GridWorldSize + u_GridCenter;
                vec3 voxelMax_World = voxelMin_World + voxelWorldSize;

                if (TriangleIntersectsAABB(v_0, v_1, v_2, voxelMin_World, voxelMax_World)) 
                {
                    imageAtomicOr(u_OccupancyGrid, currentVoxelCoord, 1u); // Set Alpha to 1u

                    if (hasEmission) 
                    {
                        imageAtomicAdd(u_EmissionR, currentVoxelCoord, encodedEmission.r);
                        imageAtomicAdd(u_EmissionG, currentVoxelCoord, encodedEmission.g);
                        imageAtomicAdd(u_EmissionB, currentVoxelCoord, encodedEmission.b);
                    }
                }
            }
        }
    }
}