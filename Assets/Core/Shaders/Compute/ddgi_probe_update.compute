#version 460

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout (binding = 0) uniform samplerCube u_SkyboxSampler;
layout (binding = 1) uniform usampler3D u_VoxelGridSampler;

// probe data
struct DDGIProbe
{
    vec4 WorldPosition;     
    vec4 SHCoeffs[9];       
    float Depth;            
    float DepthMoment2;     
};

// struct for storing debug ray info
struct DebugRay
{
    vec3 origin;
    vec3 hit;
    vec3 color;
};

layout (std430, binding = 7) buffer ProbeBuffer
{
    DDGIProbe probes[];
};

layout(std430, binding = 4) buffer DebugRayBuffer
{
    DebugRay debugRays[];
};

layout(std140, binding = 5) uniform ShaderGlobalData 
{
    mat4 viewMatrix;
    mat4 projMatrix;
    vec4 camPos;
    vec4 camDir;
    vec2 timeInfo;
    vec2 windowSize;
    int frameCount;
};

// uniforms
uniform int u_DebugRayCount;
uniform int u_DebugProbeIndex;
uniform ivec3 u_ProbeGridResolution;
uniform int u_RaysPerProbe;
uniform float u_BlendFactor;

uniform vec3 u_VoxelGridCenter;
uniform vec3 u_VoxelGridWorldSize;
uniform ivec3 u_VoxelGridResolution;

// ray marching constants
const float maxDistance = 5.0; 
const float epsilon = 0.00001;


vec3[9] ProjectOntoSH9(vec3 sampleColor, vec3 direction) 
{
    vec3 n = normalize(direction);
    float x = n.x;
    float y = n.y;
    float z = n.z;
    
    vec3[9] sh;
    // Band 0 (L=0)
    sh[0] = sampleColor * 0.2820947918; // Y00 = 1/(2*sqrt(π))
    
    // Band 1 (L=1)
    sh[1] = sampleColor * -0.4886025119 * y; // Y1-1 = sqrt(3/π)*y
    sh[2] = sampleColor * 0.4886025119 * z;  // Y10  = sqrt(3/π)*z
    sh[3] = sampleColor * -0.4886025119 * x; // Y11  = sqrt(3/π)*x
    
    // Band 2 (L=2)
    sh[4] = sampleColor * 1.0925484306 * x * y; // Y2-2 = sqrt(15/π)*xy
    sh[5] = sampleColor * -1.0925484306 * y * z; // Y2-1 = sqrt(15/π)*yz
    sh[6] = sampleColor * 0.3153915652 * (3.0*z*z - 1.0); // Y20 = sqrt(5/π)*(3z²-1)/2
    sh[7] = sampleColor * -1.0925484306 * x * z; // Y21 = sqrt(15/π)*xz
    sh[8] = sampleColor * 0.5462742153 * (x*x - y*y); // Y22 = sqrt(15/π)*(x²-y²)/2
    
    return sh;
}

vec3 SampleFibonacciSphere(uint i, uint total)
{
    const float GOLDEN_RATIO = 1.61803398875;
    float u = float(i);
    float v = float(total);

    float phi = 2.0 * 3.14159265 * fract(u * GOLDEN_RATIO);
    float cosTheta = 1.0 - 2.0 * (u + 0.5) / v;
    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);

    return normalize(vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta));
}

// raymarch the 3d voxel texture
bool RaymarchVoxelGrid(
    vec3 origin, vec3 dir, usampler3D voxelGrid,
    vec3 gridCenter, vec3 gridWorldSize, ivec3 gridResolution,
    float maxDist, out vec3 hitPos, out float hitDist
) 
{
   float t = 0.0;

   // calculate step size based on world size and resolution
   vec3 voxelWorldSize = gridWorldSize / vec3(gridResolution); // size of one voxel
   float minVoxelDim = max(epsilon, min(min(voxelWorldSize.x, voxelWorldSize.y), voxelWorldSize.z));
   float stepSize = minVoxelDim * 0.5;
   int marchMaxSteps = int(maxDist / max(epsilon, stepSize));

   for (int step = 0; step < marchMaxSteps; ++step) 
   {
       vec3 samplePosWorld = origin + dir * t;

       // I'm using center based voxel grid, so have to offset everything by half
       // Alternative is to directly calculate the minimum corner and send it in a uniform
       vec3 posRelativeToCenter = samplePosWorld - gridCenter;
       vec3 normalizedPos_NegHalfToPosHalf = posRelativeToCenter / gridWorldSize;
       vec3 normalizedPos_0_to_1 = normalizedPos_NegHalfToPosHalf + 0.5;
       ivec3 voxelCoord = ivec3(floor(normalizedPos_0_to_1 * vec3(gridResolution)));

       // bounds check
       if (any(lessThan(voxelCoord, ivec3(0))) || any(greaterThanEqual(voxelCoord, gridResolution))) 
       {
            break; 
       }

       uint occupancy = texelFetch(voxelGrid, voxelCoord, 0).r;

       if (occupancy > 0u) 
       {
           hitPos = samplePosWorld;
           hitDist = t;
           return true;
       }

       t += stepSize;
       if (t >= maxDist) 
       {
           break;
       }
   }

   hitDist = maxDist;
   hitPos = origin + dir * maxDist;
   return false;
}

void ResetDebugRays(int index)
{
    for (int i = 0; i < u_RaysPerProbe; i++)
    {
        if (i < u_DebugRayCount && i < debugRays.length() && u_DebugProbeIndex == index)
        {
            debugRays[i].origin = vec3(0);
            debugRays[i].hit = vec3(0);
            debugRays[i].color = vec3(0);
        }
    }
}

void main()
{
    // index of the probe to update
    ivec3 probeCoord = ivec3(gl_GlobalInvocationID.x,
                            gl_GlobalInvocationID.y,
                            gl_GlobalInvocationID.z);

    if (probeCoord.x >= u_ProbeGridResolution.x ||
        probeCoord.y >= u_ProbeGridResolution.y ||
        probeCoord.z >= u_ProbeGridResolution.z)
    {
        return; 
    }

    uint index = uint(probeCoord.x +
                    probeCoord.y * u_ProbeGridResolution.x +
                    probeCoord.z * u_ProbeGridResolution.x * u_ProbeGridResolution.y);

    // shouldn't occur, but just incase 
    if (index >= probes.length()) return;

    DDGIProbe probe = probes[index];

    if (index == u_DebugProbeIndex)
    {
        ResetDebugRays(u_DebugProbeIndex);
    }

    // probe with default depth as 0.0 means it intersects so do an early out check
    if (abs(probe.Depth - 0.0) < epsilon && abs(probe.DepthMoment2 - 0.0) < epsilon)
        return;

    vec3[9] accumulatedSH;
    for (int i = 0; i < 9; i++) 
    {
        accumulatedSH[i] = vec3(0.0);
    }
    float accumulatedDistance = 0.0;
    float accumulatedDistanceSq = 0.0;

    for (int i = 0; i < u_RaysPerProbe; i++)
    {
        vec3 origin = probe.WorldPosition.xyz;
        vec3 dir = SampleFibonacciSphere(uint(i), uint(u_RaysPerProbe)); // ensure uint cast

        float currentRayHitDist = maxDistance;
        vec3 currentRaySampleColor = vec3(0.0); // default to black

        // Debug visualization defaults
        vec3 debugHitPos = origin + dir * maxDistance; 
        vec3 debugRayColor = vec3(0.0, 0.0, 0.0); 

        vec3 hitPos;
        float hitDist;

        bool didHit = RaymarchVoxelGrid(
            origin, dir,
            u_VoxelGridSampler, 
            u_VoxelGridCenter,       
            u_VoxelGridWorldSize,    
            u_VoxelGridResolution, 
            maxDistance,
            hitPos, hitDist
        );

        if (didHit)
        {
            currentRaySampleColor = vec3(0.0); 
            currentRayHitDist = hitDist;       

            debugHitPos = hitPos;
            debugRayColor = vec3(0.8, 0.8, 0.8); 
        }
        else
        {
            currentRaySampleColor = texture(u_SkyboxSampler, dir).rgb; 
            currentRayHitDist = maxDistance; // Distance is max on miss

            debugHitPos = origin + dir * maxDistance; 
            debugRayColor = currentRaySampleColor;    
        }
       
        vec3[9] shContrib = ProjectOntoSH9(currentRaySampleColor, dir);
        for (int j = 0; j < 9; ++j) 
        {
            accumulatedSH[j] += shContrib[j];
        }
        accumulatedDistance += currentRayHitDist;
        accumulatedDistanceSq += currentRayHitDist * currentRayHitDist;
      
        if (index == u_DebugProbeIndex && i < u_DebugRayCount && i < debugRays.length())
        {
            int debugRayIndex = i; 
            if (didHit)
            {
                debugRays[debugRayIndex].origin = origin;
                debugRays[debugRayIndex].hit = debugHitPos;
                debugRays[debugRayIndex].color = debugRayColor;
            }
            else
            {
                debugRays[debugRayIndex].origin = origin; 
                debugRays[debugRayIndex].hit = origin + (maxDistance * dir);    
                debugRays[debugRayIndex].color = vec3(0.0);
            }
        }
    }

    if (u_RaysPerProbe > 0)
    {
        float invRaysPerProbe = 1.0 / float(u_RaysPerProbe);

        for (int i = 0; i < 9; i++) 
        {
            vec3 currentSH = accumulatedSH[i] * invRaysPerProbe;
            probes[index].SHCoeffs[i].xyz = mix(probe.SHCoeffs[i].xyz, currentSH, u_BlendFactor);
        }

        // Average and blend distance moments
        float meanDistance = accumulatedDistance * invRaysPerProbe;
        float meanSqDistance = accumulatedDistanceSq * invRaysPerProbe;
       
        probes[index].Depth = mix(probe.Depth, meanDistance, u_BlendFactor);
        probes[index].DepthMoment2 = mix(probe.DepthMoment2, meanSqDistance, u_BlendFactor);
    }
    else 
    {
        for (int i = 0; i < 9; i++) {
            probes[index].SHCoeffs[i].xyz = mix(probe.SHCoeffs[i].xyz, vec3(0.0), u_BlendFactor);
        }
        probes[index].Depth = mix(probe.Depth, 0.0, u_BlendFactor);
        probes[index].DepthMoment2 = mix(probe.DepthMoment2, 0.0, u_BlendFactor);
    }
}