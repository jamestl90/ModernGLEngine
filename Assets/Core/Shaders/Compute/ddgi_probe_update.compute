#version 460

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

// input sampler bindings
layout(binding = 0) uniform sampler2D u_PositionBuffer;
layout(binding = 1) uniform sampler2D u_NormalBuffer;
layout(binding = 2) uniform sampler2D u_AlbedoBuffer;
layout(binding = 6) uniform sampler2D u_DepthBuffer; // Linear

// probe data
struct DDGIProbe
{
    vec4 WorldPosition;
    vec4 Irradiance;
    float HitDistance;
};

// struct for storing debug ray info
struct DebugRay
{
    vec3 origin;
    vec3 hit;
    vec3 color;
};

layout (std430, binding = 7) buffer ProbeBuffer
{
    DDGIProbe probes[];
};

layout(std430, binding = 4) buffer DebugRayBuffer
{
    DebugRay debugRays[];
};

layout(std140, binding = 5) uniform ShaderGlobalData 
{
    mat4 viewMatrix;
    mat4 projMatrix;
    vec4 camPos;
    vec4 camDir;
    vec2 timeInfo;
    vec2 windowSize;
    int frameCount;
};

// uniforms
uniform int u_DebugRayCount;
uniform int u_DebugProbeIndex;
uniform ivec3 u_GridResolution;
uniform vec3 u_ProbeSpacing;
uniform vec3 u_GridOrigin;
uniform int u_RaysPerProbe;
uniform float u_BlendFactor;
uniform mat4 u_InverseView;
uniform float u_HitThreshold;

// ray marching constants
const int maxSteps = 64;
const float maxDistance = 8.0;
const float stepSize = maxDistance / float(maxSteps);
const float normalThreshold = 0.05; 
const float minStepSize = 0.02;  // Start small for accuracy
const float maxStepSize = 3.0;   // Cap for performance
const float stepScale = 0.2;

// fast and effective way to distribute points 
// evenly (uniformly?) on a sphere
vec3 SampleFibonacciSphere(uint i, uint total)
{
    const float GOLDEN_RATIO = 1.61803398875;
    float u = float(i);
    float v = float(total);

    float phi = 2.0 * 3.14159265 * fract(u * GOLDEN_RATIO);
    float cosTheta = 1.0 - 2.0 * (u + 0.5) / v;
    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);

    return vec3(cos(phi) * sinTheta, cosTheta, sin(phi) * sinTheta);
}

float LinearizeDepth(float depth)
{
    float near = 0.1;
    float far = 70.0;

    float z = depth * 2.0 - 1.0; // Convert to NDC space
    return (2.0 * near * far) / (far + near - z * (far - near));
}

// raymarch using the gbuffer
bool RaymarchGBufferHit(
    vec3 origin,
    vec3 dir,
    out vec3 hitPos,
    out vec3 hitNormal,
    out vec3 hitAlbedo,
    out int stepsTaken)
{
    float t = 0.0; // Start at origin like original
    mat4 viewProjMatrix = projMatrix * viewMatrix;
    // Need camPos for the rayDepth calculation
    // Need windowSize for pixel coordinates
    // Need u_HitThreshold for BOTH checks

    // Constants for adaptive step (matching your list)

    for (int step = 0; step < maxSteps; ++step)
    {
        vec3 samplePosWorld = origin + dir * t; // Current point along the ray

        // --- Screen Space Projection ---
        vec4 samplePosClip = viewProjMatrix * vec4(samplePosWorld, 1.0);
        if (samplePosClip.w <= 0.0) { break; } // Behind camera

        vec3 ndc = samplePosClip.xyz / samplePosClip.w;
        vec2 uv = ndc.xy * 0.5 + 0.5;

        if (any(lessThan(uv, vec2(0.0))) || any(greaterThan(uv, vec2(1.0)))) { break; } // Off screen

        // --- Replicate Original Checks ---
        ivec2 pixel = ivec2(uv * windowSize);

        // Fetch Linearized Depth from buffer
        float sceneDepth = texelFetch(u_DepthBuffer, pixel, 0).r;
        // Calculate World distance from current ray sample point to camera position
        float rayDepth = length(samplePosWorld - camPos.xyz);

        // Check 1: Original Depth Comparison (Camera-relative)
        if (rayDepth > sceneDepth - u_HitThreshold)
        {
            vec3 gBufferWorldPos = texelFetch(u_PositionBuffer, pixel, 0).rgb;
            if (distance(samplePosWorld, gBufferWorldPos) < u_HitThreshold)
            {
                hitPos = gBufferWorldPos; 
                hitAlbedo = texelFetch(u_AlbedoBuffer, pixel, 0).rgb;
                vec3 gBufferNormalRaw = texelFetch(u_NormalBuffer, pixel, 0).rgb;
                vec3 surfaceNormalWS = normalize(mat3(u_InverseView) * gBufferNormalRaw);
                hitNormal = normalize(surfaceNormalWS);
                stepsTaken = step;

                float NdotV = dot(surfaceNormalWS, -dir);
                if (NdotV > normalThreshold)
                {
                    return true;
                }                
            }
        }

        t += max(minStepSize, t * 0.2);
        if (t > maxDistance) { break; } // Max distance check
    }

    // Loop finished without returning true
    stepsTaken = maxSteps;
    return false;
}

void ResetDebugRays(int index)
{
    for (int i = 0; i < u_RaysPerProbe; i++)
    {
        if (i < u_DebugRayCount && i < debugRays.length() && u_DebugProbeIndex == index)
        {
            debugRays[i].origin = vec3(0);
            debugRays[i].hit = vec3(0);
            debugRays[i].color = vec3(0);
        }
    }
}

void main()
{
    // index of the probe to update
    uint index = gl_GlobalInvocationID.x + 
                 gl_GlobalInvocationID.y * u_GridResolution.x + 
                 gl_GlobalInvocationID.z * u_GridResolution.x * u_GridResolution.y;

    // shouldn't occur, but just incase 
    if (index >= probes.length()) return;

    DDGIProbe probe = probes[index];

    if (index == u_DebugProbeIndex)
    {
        ResetDebugRays(u_DebugProbeIndex);
    }

    vec3 accumulatedIrradiance = vec3(0.0); 
    float accumulatedDistance = 0.0;

    for (int i = 0; i < u_RaysPerProbe; i++)
    {
        vec3 origin = probe.WorldPosition.xyz;
        vec3 dir = SampleFibonacciSphere(i, u_RaysPerProbe);

        // setup defaults
        float currentRayHitDist = maxDistance;
        vec3 currentRaySampleColor = vec3(0.1, 0.1, 0.3);
        vec3 hitPos = origin + dir * maxDistance;
        vec3 hitAlbedo = vec3(1.0);
        vec3 hitNormal = vec3(0.0, 1.0, 0.0);

        vec3 debugHitPos = origin;
        vec3 debugRayColor = vec3(0,0,1);

        int stepsTaken = 0;
        if (RaymarchGBufferHit(origin, dir, hitPos, hitNormal, hitAlbedo, stepsTaken))
        {
            float NdotL = max(dot(hitNormal, -dir), 0.0);
            // Update the values for *this* ray's hit
            currentRaySampleColor = hitAlbedo * NdotL;
            currentRayHitDist = length(hitPos - origin);
            // Update debug info for hit
            debugRayColor = hitAlbedo;
            debugHitPos = hitPos;
        }

        accumulatedIrradiance += currentRaySampleColor;
        accumulatedDistance += currentRayHitDist;

        if (i < u_DebugRayCount && i < debugRays.length() && index == u_DebugProbeIndex)
        {
            debugRays[i].origin = origin;
            debugRays[i].hit = debugHitPos; // Use the correct endpoint for hit/miss
            debugRays[i].color = debugRayColor; // Use the correct color for hit/miss
        }
    }

    if (u_RaysPerProbe > 0)
    {
        vec3 currentFrameIrradiance = accumulatedIrradiance / float(u_RaysPerProbe);
        float currentFrameDistance = accumulatedDistance / float(u_RaysPerProbe);

        vec3 blendedIrradiance = mix(probe.Irradiance.rgb, currentFrameIrradiance, u_BlendFactor);
        float blendedDistance = mix(probe.HitDistance, currentFrameDistance, u_BlendFactor);

        probes[index].Irradiance.rgb = blendedIrradiance;
        probes[index].HitDistance = blendedDistance;
    }
    else
    {
        // Handle 0 rays case
        probes[index].Irradiance.rgb = mix(probe.Irradiance.rgb, vec3(0.0), u_BlendFactor);
        probes[index].HitDistance    = mix(probe.HitDistance, 0.0, u_BlendFactor);
    }
}