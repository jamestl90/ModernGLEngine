#version 460

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

// input sampler bindings
layout(binding = 0) uniform sampler2D u_PositionBuffer;
layout(binding = 1) uniform sampler2D u_NormalBuffer;
layout(binding = 2) uniform sampler2D u_AlbedoBuffer;

// probe data
struct DDGIProbe
{
    vec4 WorldPosition;
    vec4 Irradiance;
    float HitDistance;
    vec3 _pad;
};

// struct for storing debug ray info
struct DebugRay
{
    vec3 origin;
    vec3 hit;
};

layout (std430, binding = 3) buffer ProbeBuffer
{
    DDGIProbe probes[];
};

layout(std430, binding = 4) buffer DebugRayBuffer
{
    DebugRay debugRays[];
};

layout(std140, binding = 5) uniform ShaderGlobalData 
{
    mat4 viewMatrix;
    mat4 projMatrix;
    vec4 camPos;
    vec4 camDir;
    vec2 timeInfo;
    vec2 windowSize;
    int frameCount;
};

// uniforms
uniform int u_DebugRayCount;
uniform uint u_DebugProbeIndex;
uniform ivec3 u_GridResolution;
uniform vec3 u_ProbeSpacing;
uniform vec3 u_GridOrigin;
uniform int u_RaysPerProbe;
uniform float u_BlendFactor;
uniform mat4 u_InverseView;

// 64 steps at 0.25 a step will be 16 units of ray distance
const int maxSteps = 64;
const float stepSize = 0.25;
const float maxDistance = 16;
const float hitThreshold = 0.2;

// fast and effective way to distribute points 
// evenly (uniformly?) on a sphere
vec3 SampleFibonacciSphere(uint i, uint total)
{
    const float GOLDEN_RATIO = 1.61803398875;
    float u = float(i);
    float v = float(total);

    float phi = 2.0 * 3.14159265 * fract(u * GOLDEN_RATIO);
    float cosTheta = 1.0 - 2.0 * (u + 0.5) / v;
    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);

    return vec3(cos(phi) * sinTheta, cosTheta, sin(phi) * sinTheta);
}

// raymarch using the gbuffer
bool RaymarchGBufferHit(vec3 origin, vec3 dir, out vec3 hitPos, out vec3 hitNormal, out vec3 hitAlbedo)
{
    for (int step = 0; step < maxSteps; step++)
    {
        float t = float(step) * stepSize;
        vec3 samplePos = origin + dir * t;

        // project to screen space
        vec4 viewPos = viewMatrix * vec4(samplePos, 1.0);
        vec4 clipPos = projMatrix * viewPos;
        vec3 ndc = clipPos.xyz / clipPos.w; // normalize
        vec2 uv = ndc.xy * 0.5 + 0.5;

        // bounds checking
        if (uv.x < 0.0 || uv.y < 0.0 || uv.x > 1.0 || uv.y > 1.0)
            break;

        vec3 gBufferPos = texture(u_PositionBuffer, uv).rgb;
        float distToSurface = length(gBufferPos - samplePos);

        if (distToSurface < hitThreshold)
        {
            hitPos = gBufferPos;
            hitNormal = texture(u_NormalBuffer, uv).rgb;
            hitNormal = normalize((mat3(u_InverseView) * hitNormal));
            hitAlbedo = texture(u_AlbedoBuffer, uv).rgb;
            return true;
        }
    }
    return false;
}

void main()
{
    // index of the probe to update
    uint index = gl_GlobalInvocationID.x + 
                 gl_GlobalInvocationID.y * u_GridResolution.x + 
                 gl_GlobalInvocationID.z * u_GridResolution.x * u_GridResolution.y;

    // shouldn't occur, but just incase 
    if (index >= probes.length()) return;

    DDGIProbe probe = probes[index];

    vec3 totalIrradiance = vec3(0.0);
    float totalDistance = 0.0;

    for (int i = 0; i < u_RaysPerProbe; i++)
    {
        vec3 origin = probe.WorldPosition.xyz;
        vec3 dir = SampleFibonacciSphere(i, u_RaysPerProbe);

        // setup defaults
        vec3 hitPos = origin + dir * 5.0;
        vec3 hitAlbedo = vec3(1.0);
        vec3 hitNormal = vec3(0.0, 1.0, 0.0);

        if (RaymarchGBufferHit(origin, dir, hitPos, hitNormal, hitAlbedo))
        {
            vec3 incomingLight = vec3(1.0);
            vec3 irradiance = hitAlbedo * incomingLight * max(dot(-dir, hitNormal), 0.0);
            totalIrradiance += irradiance;
            totalDistance += length(hitPos - origin);
        }
        else
        {
            totalDistance += maxDistance;
            hitPos = origin;
        }

        if (i < u_DebugRayCount && i < debugRays.length() && index == 0)
        {
            debugRays[i].origin = origin;
            debugRays[i].hit = hitPos;
        }
    }

    // average out the accumulated irradiance and distance
    totalIrradiance /= float(u_RaysPerProbe);
    totalDistance /= float(u_RaysPerProbe);

    probe.Irradiance.rgb = mix(probe.Irradiance.rgb, totalIrradiance, u_BlendFactor);
    probe.HitDistance = mix(probe.HitDistance, totalDistance, u_BlendFactor);

    probes[index] = probe;
}